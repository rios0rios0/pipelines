jobs:
  - job: 'execute_database_migrations'
    displayName: 'database:migrations'
    steps:
      - task: 'AzureCLI@2'
        displayName: 'Check if Database Exists'
        inputs:
          azureSubscription: "$(AZM_SERVICE_CONNECTION)"
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            DATABASE_SERVER_NAME=$(echo $OUTPUTS | jq -r '.databaseServerName.value')
            if [[ -z "$DATABASE_SERVER_NAME" || "$DATABASE_SERVER_NAME" == "null" ]]; then
              echo "Invalid database server name: $DATABASE_SERVER_NAME"
              echo "##vso[task.setvariable variable=DB_EXISTS]false"
              exit 0
            fi

            dbExists=$(az postgres flexible-server show --resource-group "$(resourceGroupName)" --name "$DATABASE_SERVER_NAME" --query "name" --output tsv 2>/dev/null || echo "null")
            if [[ "$dbExists" != "null" ]]; then
              echo "##vso[task.setvariable variable=DB_EXISTS]true"
            else
              echo "##vso[task.setvariable variable=DB_EXISTS]false"
            fi

      - task: 'AzureCLI@2'
        displayName: 'Create Flexible Firewall Rule to execute migrations and seeders'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))
        inputs:
          azureSubscription: "$(AZM_SERVICE_CONNECTION)"
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
                set -e

                DATABASE_SERVER_NAME=$(echo $OUTPUTS | jq -r '.databaseServerName.value')
                PIPELINE_IP=$(curl -s ifconfig.me/ip)

                az postgres flexible-server firewall-rule create \
                    --resource-group "$(resourceGroupName)" \
                    --name "$DATABASE_SERVER_NAME" \
                    --rule-name "$(PIPELINE_FIREWALL_NAME)" \
                    --start-ip-address "$PIPELINE_IP"
      - script: |
              set -e
              PORT=$(echo $OUTPUTS | jq -r '.databaseServerPort.value')
              HOST=$(echo $OUTPUTS | jq -r '.databaseServerHost.value')
              USER=$(echo $OUTPUTS | jq -r '.databaseServerUsername.value')
              PASSWORD=$(echo $OUTPUTS | jq -r '.databaseServerPassword.value')
              DBNAME=$(echo $OUTPUTS | jq -r '.databaseName.value')
              SSL=$(echo $OUTPUTS | jq -r '.databaseServerSSL.value')

              CONNECTION_STRING="host=$HOST port=$PORT user=$USER password=$PASSWORD dbname=$DBNAME sslmode=$SSL"
              echo "##vso[task.setvariable variable=CONNECTION_STRING]$CONNECTION_STRING"
        displayName: 'Set Database Connection String'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))

      - script: |
              set -e
              table_hash=$(psql "$(CONNECTION_STRING)" -t -c \
              "SELECT md5(string_agg(concat_ws('|', version_id::text, is_applied::text), ',' ORDER BY id)) AS table_hash FROM goose_db_version;")
              table_hash=$(echo "$table_hash" | xargs)
              echo "table_hash: $table_hash"
              echo "##vso[task.setvariable variable=GOOSE_TABLE_HASH]$table_hash"
        displayName: 'Set Goose Table Hash variable'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))
        continueOnError: true

      - task: 'Cache@2'
        displayName: 'Cache for Migrations'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))
        inputs:
              key: "$(Agent.JobName)|$(ENVIRONMENT)|$(GOOSE_TABLE_HASH)|db/migrations/*.sql"
              path: "$(MIGRATIONS_CACHE)"
              cacheHitVar: 'MIGRATIONS_CACHE_HIT'
        continueOnError: true
        
      - task: 'Cache@2'
        displayName: 'Cache for Seeders'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))
        inputs:
              key: "$(Agent.JobName)|$(ENVIRONMENT)|$(GOOSE_TABLE_HASH)|db/seeders/*.sql"
              path: "$(SEEDERS_CACHE)"
              cacheHitVar: 'SEEDERS_CACHE_HIT'
        continueOnError: true

      - task: 'AzureCLI@2'
        inputs:
          displayName: 'Execute Migrations'
          condition: and(succeeded(), eq(variables['MIGRATIONS_CACHE_HIT'], 'false'))
          azureSubscription: "$(AZM_SERVICE_CONNECTION)"
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
                set -e

                # TODO: move this "IF" to a file and (or) use an Azure resource to create a condition
                if grep -r 'goose' db/migrations/*.sql; then
                  go install github.com/pressly/goose/v3/cmd/goose@v3.17.0

                  $(go env GOPATH)/bin/goose -dir db/migrations postgres "$(CONNECTION_STRING)" up

                else
                  echo "No Goose migration files found. Skipping Goose installation and migration."
                fi

      - task: 'AzureCLI@2'
        inputs:
          displayName: 'Execute Seeders'
          condition: and(succeeded(), eq(variables['SEEDERS_CACHE_HIT'], 'false'))
          azureSubscription: "$(AZM_SERVICE_CONNECTION)"
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            set -e

            if grep -r 'goose' db/seeders/*.sql; then
              go install github.com/pressly/goose/v3/cmd/goose@v3.22.1

              for dir in "" "dev" "prod"; do
                  if [ -z "$dir" ] || [ "$ENVIRONMENT" == "$dir" ]; then
                    dir_path="db/seeders/$dir"
                    dir_path=${dir_path%/}
                    if grep -q 'goose' $dir_path/*.sql; then
                        $(go env GOPATH)/bin/goose -dir $dir_path postgres "$(CONNECTION_STRING)" up
                    fi
                  fi
              done
            else
                echo "No Goose seed files found. Skipping seed"
            fi

      - task: 'AzureCLI@2'
        displayName: 'Delete Flexible Firewall Rule to execute migrations and seeders'
        condition: and(succeeded(), eq(variables['DB_EXISTS'], 'true'))
        inputs:
          azureSubscription: "$(AZM_SERVICE_CONNECTION)"
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
                set -e

                DATABASE_SERVER_NAME=$(echo $OUTPUTS | jq -r '.databaseServerName.value')
                PIPELINE_IP=$(curl -s ifconfig.me/ip)

                az postgres flexible-server firewall-rule delete --yes \
                  --resource-group "$(resourceGroupName)" \
                  --name "$DATABASE_SERVER_NAME" \
                  --rule-name "$(PIPELINE_FIREWALL_NAME)"
